{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"OSMDiff Documentation","text":"<p>OSMDiff provides Python tools for working with OpenStreetMap change data:</p> <ul> <li>Track real-time map edits</li> <li>Process historical changes</li> <li>Monitor specific geographic areas</li> <li>Analyze contributor patterns</li> </ul>"},{"location":"#quick-links","title":"Quick Links","text":"<ul> <li>Getting Started - First steps with OSMDiff</li> <li>API Reference - Detailed documentation</li> <li>Examples - More advanced usage patterns</li> </ul>"},{"location":"getting-started/","title":"Getting Started with OSMDiff","text":"<p>OSMDiff helps you work with OpenStreetMap change data. OpenStreetMap (OSM) is a collaborative map that\u2019s constantly updated by volunteers. These updates come in different formats:</p> <ul> <li>Augmented Diffs: Detailed changes including metadata about who made changes and why</li> <li>OSMChange: Standard format for basic create/modify/delete operations</li> </ul>"},{"location":"getting-started/#installation","title":"Installation","text":"<pre><code>pip install osmdiff\n</code></pre>"},{"location":"getting-started/#basic-usage","title":"Basic Usage","text":"<p>Track changes in a specific area (here using London as an example):</p> <pre><code>from osmdiff import AugmentedDiff\n\n# Create an AugmentedDiff instance for London\nad = AugmentedDiff(\n    minlon=-0.489,  # West\n    minlat=51.28,   # South \n    maxlon=0.236,   # East\n    maxlat=51.686   # North\n)\n\n# Get current state and retrieve changes\nad.get_state()\nstatus = ad.retrieve()\n\nif status == 200:\n    print(f\"Changes retrieved:\")\n    print(f\"  Created: {len(ad.create)}\")\n    print(f\"  Modified: {len(ad.modify)}\")\n    print(f\"  Deleted: {len(ad.delete)}\")\n</code></pre>"},{"location":"getting-started/#continuous-monitoring","title":"Continuous Monitoring","text":"<p>For real-time monitoring of changes:</p> <pre><code>from osmdiff import ContinuousAugmentedDiff\n\n# Create continuous fetcher for London area\nfetcher = ContinuousAugmentedDiff(\n    minlon=-0.489,\n    minlat=51.28, \n    maxlon=0.236,\n    maxlat=51.686,\n    min_interval=30,  # Check at least every 30 seconds\n    max_interval=120  # Back off up to 120 seconds if no changes\n)\n\n# Process changes as they come in\nfor diff in fetcher:\n    print(f\"\\nNew changes in diff {diff.sequence_number}:\")\n    print(f\"  Created: {len(diff.create)} objects\")\n    print(f\"  Modified: {len(diff.modify)} objects\")\n    print(f\"  Deleted: {len(diff.delete)} objects\")\n\n    # Example: Track new amenities\n    for obj in diff.create:\n        if \"amenity\" in obj.tags:\n            print(f\"New amenity: {obj.tags['amenity']}\")\n</code></pre>"},{"location":"getting-started/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about AugmentedDiff API</li> <li>Explore OSMChange format</li> <li>See OSM Objects you can work with</li> </ul>"},{"location":"api/augmenteddiff/","title":"AugmentedDiff","text":"<p>Core class for retrieving and parsing OpenStreetMap augmented diffs.</p> <p>For continuous monitoring of changes, see ContinuousAugmentedDiff.</p>"},{"location":"api/augmenteddiff/#features","title":"Features","text":"<ul> <li>Single diff retrieval</li> <li>Bounding box filtering</li> <li>Automatic sequence number handling</li> <li>Context manager support</li> </ul>"},{"location":"api/augmenteddiff/#basic-usage","title":"Basic Usage","text":"<pre><code>from osmdiff import AugmentedDiff\n\n# Create with bounding box for London\nadiff = AugmentedDiff(\n    minlon=-0.489,\n    minlat=51.28,\n    maxlon=0.236,\n    maxlat=51.686\n)\n\n# Retrieve and process changes\nstatus = adiff.retrieve()\nif status == 200:\n    print(f\"Created: {len(adiff.create)} features\")\n    print(f\"Modified: {len(adiff.modify)} features\")\n    print(f\"Deleted: {len(adiff.delete)} features\")\n</code></pre>"},{"location":"api/augmenteddiff/#api-reference","title":"API Reference","text":"<p>An Augmented Diff representation for OpenStreetMap changes.</p> <p>Handles retrieval and parsing of OpenStreetMap augmented diffs containing detailed changes to OSM data (creations, modifications, deletions).</p> <p>Parameters:</p> Name Type Description Default <code>minlon</code> <code>Optional[float]</code> <p>Minimum longitude of bounding box (WGS84)</p> <code>None</code> <code>minlat</code> <code>Optional[float]</code> <p>Minimum latitude of bounding box (WGS84)</p> <code>None</code> <code>maxlon</code> <code>Optional[float]</code> <p>Maximum longitude of bounding box (WGS84)</p> <code>None</code> <code>maxlat</code> <code>Optional[float]</code> <p>Maximum latitude of bounding box (WGS84)</p> <code>None</code> <code>file</code> <code>Optional[str]</code> <p>Path to local augmented diff XML file</p> <code>None</code> <code>sequence_number</code> <code>Optional[int]</code> <p>Sequence number of the diff</p> <code>None</code> <code>base_url</code> <code>Optional[str]</code> <p>Override default Overpass API URL</p> <code>None</code> <code>timeout</code> <code>Optional[int]</code> <p>Request timeout in seconds</p> <code>None</code> Note <p>The bounding box coordinates should be in WGS84 (EPSG:4326) format.</p> Source code in <code>src/osmdiff/augmenteddiff.py</code> <pre><code>def __init__(\n    self,\n    minlon: Optional[float] = None,\n    minlat: Optional[float] = None,\n    maxlon: Optional[float] = None,\n    maxlat: Optional[float] = None,\n    file: Optional[str] = None,\n    sequence_number: Optional[int] = None,\n    timestamp: Optional[datetime] = None,\n    base_url: Optional[str] = None,\n    timeout: Optional[int] = None,\n) -&gt; None:\n    # Initialize with defaults from config\n    self.base_url = base_url or API_CONFIG[\"overpass\"][\"base_url\"]\n    self.timeout = timeout or API_CONFIG[\"overpass\"][\"timeout\"]\n\n    # Initialize other config values\n    self.minlon = minlon\n    self.minlat = minlat\n    self.maxlon = maxlon\n    self.maxlat = maxlat\n    self.timestamp = timestamp\n    self._remarks = []\n    self._sequence_number = None\n    self._create = []\n    self._modify = []\n    self._delete = []\n    if file:\n        with open(file, \"r\") as file_handle:\n            self._parse_stream(file_handle)\n    else:\n        self.sequence_number = sequence_number\n        if minlon and minlat and maxlon and maxlat:\n            if maxlon &gt; minlon and maxlat &gt; minlat:\n                self.minlon = minlon\n                self.minlat = minlat\n                self.maxlon = maxlon\n                self.maxlat = maxlat\n            else:\n                raise Exception(\"invalid bbox.\")\n    self._logger = logging.getLogger(__name__)\n</code></pre>"},{"location":"api/augmenteddiff/#osmdiff.augmenteddiff.AugmentedDiff.sequence_number","title":"<code>sequence_number</code>  <code>property</code> <code>writable</code>","text":"<p>Get the sequence number identifying this diff.</p> <p>Sequence numbers increment monotonically and uniquely identify each diff.</p>"},{"location":"api/augmenteddiff/#osmdiff.augmenteddiff.AugmentedDiff.timestamp","title":"<code>timestamp</code>  <code>property</code> <code>writable</code>","text":"<p>Get the timestamp of when the changes in this diff were made.</p> <p>Returns:</p> Name Type Description <code>datetime</code> <code>datetime</code> <p>The timestamp parsed from the diff metadata</p>"},{"location":"api/augmenteddiff/#osmdiff.augmenteddiff.AugmentedDiff.remarks","title":"<code>remarks</code>  <code>property</code>","text":"<p>Get the list of remarks from the augmented diff.</p> <p>Remarks provide additional metadata about the changes in the diff.</p>"},{"location":"api/augmenteddiff/#osmdiff.augmenteddiff.AugmentedDiff.actions","title":"<code>actions</code>  <code>property</code>","text":"<p>Get all actions combined in a single list.</p>"},{"location":"api/augmenteddiff/#osmdiff.augmenteddiff.AugmentedDiff.get_state","title":"<code>get_state(base_url=None, timeout=None)</code>  <code>classmethod</code>","text":"<p>Get the current sequence number from the Overpass API.</p> <p>Parameters:</p> Name Type Description Default <code>base_url</code> <code>Optional[str]</code> <p>Override default Overpass API URL (deprecated)</p> <code>None</code> <code>timeout</code> <code>Optional[int]</code> <p>Optional override for request timeout</p> <code>None</code> <p>Returns:</p> Name Type Description <code>int</code> <code>Optional[dict]</code> <p>Sequence number</p> Source code in <code>src/osmdiff/augmenteddiff.py</code> <pre><code>@classmethod\ndef get_state(\n    cls, base_url: Optional[str] = None, timeout: Optional[int] = None\n) -&gt; Optional[dict]:\n    \"\"\"Get the current sequence number from the Overpass API.\n\n    Args:\n        base_url: Override default Overpass API URL (deprecated)\n        timeout: Optional override for request timeout\n\n    Returns:\n        int: Sequence number\n    \"\"\"\n    state_url = API_CONFIG[\"overpass\"][\"state_url\"]\n    response = requests.get(\n        state_url, timeout=timeout or 5, headers=DEFAULT_HEADERS\n    )\n    response.raise_for_status()\n    return_dict = {\"sequence_number\": int(response.text), \"timestamp\": None}\n    return return_dict\n</code></pre>"},{"location":"api/augmenteddiff/#osmdiff.augmenteddiff.AugmentedDiff.retrieve","title":"<code>retrieve(clear_cache=False, timeout=None, auto_increment=True, max_retries=3)</code>","text":"<p>Retrieve the Augmented diff corresponding to the sequence_number.</p> <p>Parameters:</p> Name Type Description Default <code>clear_cache</code> <code>bool</code> <p>Whether to clear existing data before retrieval.</p> <code>False</code> <code>timeout</code> <code>Optional[int]</code> <p>Request timeout in seconds.</p> <code>None</code> <code>auto_increment</code> <code>bool</code> <p>Whether to automatically increment sequence number after retrieval.</p> <code>True</code> <code>max_retries</code> <code>int</code> <p>Maximum number of retry attempts for failed requests.</p> <code>3</code> <p>Returns:</p> Type Description <code>int</code> <p>HTTP status code of the request (200 for success)</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If sequence_number is not set</p> <code>RequestException</code> <p>If all retry attempts fail</p> Source code in <code>src/osmdiff/augmenteddiff.py</code> <pre><code>def retrieve(\n    self,\n    clear_cache: bool = False,\n    timeout: Optional[int] = None,\n    auto_increment: bool = True,\n    max_retries: int = 3,\n) -&gt; int:\n    \"\"\"Retrieve the Augmented diff corresponding to the sequence_number.\n\n    Args:\n        clear_cache: Whether to clear existing data before retrieval.\n        timeout: Request timeout in seconds.\n        auto_increment: Whether to automatically increment sequence number after retrieval.\n        max_retries: Maximum number of retry attempts for failed requests.\n\n    Returns:\n        HTTP status code of the request (200 for success)\n\n    Raises:\n        Exception: If sequence_number is not set\n        requests.exceptions.RequestException: If all retry attempts fail\n    \"\"\"\n    if not self.sequence_number:\n        raise Exception(\"invalid sequence number\")\n\n    if clear_cache:\n        self._create, self._modify, self._delete = ([], [], [])\n\n    url = self.base_url.format(sequence_number=self.sequence_number)\n\n    self._logger.info(f\"Retrieving diff {self.sequence_number} from {url}\")\n\n    # Store current data before making request\n    prev_create = self._create.copy()\n    prev_modify = self._modify.copy()\n    prev_delete = self._delete.copy()\n\n    # Use a longer timeout if none specified\n    request_timeout = (\n        timeout or self.timeout or 120\n    )  # 2 minutes default, this will still fail for very large diffs, like 12346\n\n    for attempt in range(max_retries):\n        try:\n            # Exponential backoff between retries\n            if attempt &gt; 0:\n                time.sleep(2**attempt)  # 2, 4, 8 seconds...\n\n            r = requests.get(\n                url, stream=True, timeout=request_timeout, headers=DEFAULT_HEADERS\n            )\n\n            if r.status_code != 200:\n                return r.status_code\n\n            r.raw.decode_content = True\n\n            # Clear current lists but keep previous data\n            self._create, self._modify, self._delete = ([], [], [])\n\n            # Parse new data\n            self._parse_stream(r.raw)\n\n            # Merge with previous data\n            self._create = prev_create + self._create\n            self._modify = prev_modify + self._modify\n            self._delete = prev_delete + self._delete\n\n            # Automatically increment sequence number after successful retrieval\n            if auto_increment:\n                self.sequence_number += 1\n\n            return r.status_code\n\n        except (\n            requests.exceptions.ReadTimeout,\n            requests.exceptions.ConnectionError,\n        ) as e:\n            if attempt == max_retries - 1:  # Last attempt\n                raise\n            continue\n\n    return 0  # Should never reach here due to raise in except block\n</code></pre>"},{"location":"api/augmenteddiff/#osmdiff.augmenteddiff.AugmentedDiff.__repr__","title":"<code>__repr__()</code>","text":"Source code in <code>src/osmdiff/augmenteddiff.py</code> <pre><code>def __repr__(self):\n    return \"\"\"AugmentedDiff ({create} created, {modify} modified, {delete} deleted)\"\"\".format(\n        create=len(self._create),\n        modify=len(self._modify),\n        delete=len(self._delete),\n    )\n</code></pre>"},{"location":"api/augmenteddiff/#osmdiff.augmenteddiff.AugmentedDiff.__enter__","title":"<code>__enter__()</code>","text":"Source code in <code>src/osmdiff/augmenteddiff.py</code> <pre><code>def __enter__(self):\n    return self\n</code></pre>"},{"location":"api/augmenteddiff/#osmdiff.augmenteddiff.AugmentedDiff.__exit__","title":"<code>__exit__(exc_type, exc_val, exc_tb)</code>","text":"Source code in <code>src/osmdiff/augmenteddiff.py</code> <pre><code>def __exit__(self, exc_type, exc_val, exc_tb):\n    self._create.clear()\n    self._modify.clear()\n    self._delete.clear()\n</code></pre>"},{"location":"api/augmenteddiff/#see-also","title":"See Also","text":"<ul> <li>ContinuousAugmentedDiff - For continuous monitoring</li> <li>OSMChange - For standard OSM changesets</li> </ul>"},{"location":"api/config/","title":"Configuration Reference","text":""},{"location":"api/config/#api-configuration","title":"API Configuration","text":""},{"location":"api/config/#augmenteddiff-defaults","title":"AugmentedDiff Defaults","text":""},{"location":"api/config/#http-settings","title":"HTTP Settings","text":""},{"location":"api/config/#overriding-configuration","title":"Overriding Configuration","text":"<pre><code>from osmdiff import AugmentedDiff\nfrom osmdiff.config import API_CONFIG\n\n# Modify configuration before use\nAPI_CONFIG[\"overpass\"][\"timeout\"] = 60  # Increase timeout\n\nadiff = AugmentedDiff()  # Will use updated configuration\n</code></pre>"},{"location":"api/continuous/","title":"ContinuousAugmentedDiff","text":"<p>Iterator for continuous monitoring of OpenStreetMap changes using augmented diffs.</p> <p>Builds on AugmentedDiff to provide automatic polling with backoff.</p>"},{"location":"api/continuous/#features","title":"Features","text":"<ul> <li>Continuous monitoring</li> <li>Automatic sequence number tracking</li> <li>Exponential backoff during errors</li> <li>Configurable polling intervals</li> <li>Bounding box filtering</li> </ul>"},{"location":"api/continuous/#basic-usage","title":"Basic Usage","text":"<pre><code>from osmdiff import ContinuousAugmentedDiff\n\n# Monitor London area\nmonitor = ContinuousAugmentedDiff(\n    minlon=-0.489,\n    minlat=51.28,\n    maxlon=0.236,\n    maxlat=51.686\n)\n\nfor changes in monitor:  # Runs indefinitely\n    print(f\"Changeset {changes.sequence_number}:\")\n    print(f\"  New: {len(changes.create)}\")\n    print(f\"  Modified: {len(changes.modify)}\")\n</code></pre>"},{"location":"api/continuous/#advanced-configuration","title":"Advanced Configuration","text":"<pre><code>monitor = ContinuousAugmentedDiff(\n    minlon=-0.489,\n    minlat=51.28,\n    maxlon=0.236,\n    maxlat=51.686,\n    min_interval=60,  # Minimum 1 minute between checks\n    max_interval=300  # Maximum 5 minutes during backoff\n)\n</code></pre>"},{"location":"api/continuous/#api-reference","title":"API Reference","text":"<p>Iterator for continuously fetching augmented diffs with backoff.</p> <p>Yields AugmentedDiff objects as new diffs become available.</p> <p>Parameters:</p> Name Type Description Default <code>minlon</code> <code>Optional[float]</code> <p>Minimum longitude of bounding box</p> <code>None</code> <code>minlat</code> <code>Optional[float]</code> <p>Minimum latitude of bounding box</p> <code>None</code> <code>maxlon</code> <code>Optional[float]</code> <p>Maximum longitude of bounding box</p> <code>None</code> <code>maxlat</code> <code>Optional[float]</code> <p>Maximum latitude of bounding box</p> <code>None</code> <code>base_url</code> <code>Optional[str]</code> <p>Override default Overpass API URL</p> <code>None</code> <code>timeout</code> <code>Optional[int]</code> <p>Request timeout in seconds</p> <code>None</code> <code>min_interval</code> <code>int</code> <p>Minimum seconds between checks (default: 30)</p> <code>30</code> <code>max_interval</code> <code>int</code> <p>Maximum seconds between checks (default: 120)</p> <code>120</code> Source code in <code>src/osmdiff/augmenteddiff.py</code> <pre><code>def __init__(\n    self,\n    minlon: Optional[float] = None,\n    minlat: Optional[float] = None,\n    maxlon: Optional[float] = None,\n    maxlat: Optional[float] = None,\n    base_url: Optional[str] = None,\n    timeout: Optional[int] = None,\n    min_interval: int = 30,\n    max_interval: int = 120,\n):\n    self.bbox = (minlon, minlat, maxlon, maxlat)\n    self.base_url = base_url\n    self.timeout = timeout\n    self.min_interval = min_interval\n    self.max_interval = max_interval\n\n    self._current_sequence = None\n    self._current_interval = min_interval\n    self._last_check = None\n    self._logger = logging.getLogger(__name__)\n</code></pre>"},{"location":"api/continuous/#osmdiff.augmenteddiff.ContinuousAugmentedDiff.__iter__","title":"<code>__iter__()</code>","text":"Source code in <code>src/osmdiff/augmenteddiff.py</code> <pre><code>def __iter__(self):\n    return self\n</code></pre>"},{"location":"api/continuous/#osmdiff.augmenteddiff.ContinuousAugmentedDiff.__next__","title":"<code>__next__()</code>","text":"Source code in <code>src/osmdiff/augmenteddiff.py</code> <pre><code>def __next__(self) -&gt; AugmentedDiff:\n    while True:\n        self._wait_for_next_check()\n\n        # check if we have a newer sequence on the remote\n        newest_remote = AugmentedDiff.get_state(timeout=self.timeout)\n\n        # if we don't have a local sequence number yet, set it\n        if self._current_sequence is None:\n            self._current_sequence = newest_remote\n\n        # if we do, proceed ony if the remote is newer\n        elif self._current_sequence &gt;= newest_remote:\n            continue\n\n        # Create diff object for new sequence\n        diff = AugmentedDiff(\n            minlon=self.bbox[0],\n            minlat=self.bbox[1],\n            maxlon=self.bbox[2],\n            maxlat=self.bbox[3],\n            sequence_number=self._current_sequence,\n            base_url=self.base_url,\n            timeout=self.timeout,\n        )\n\n        # Try to retrieve the diff\n        try:\n            status = diff.retrieve(auto_increment=False)\n            if status != 200:\n                self._logger.warning(f\"Failed to retrieve diff: HTTP {status}\")\n                self._backoff()\n                continue\n\n            # Success! Reset backoff and update sequence\n            self._reset_backoff()\n            self._current_sequence += 1\n            return diff\n\n        except Exception as e:\n            self._logger.warning(f\"Error retrieving diff: {e}\")\n            self._backoff()\n            continue\n</code></pre>"},{"location":"api/continuous/#see-also","title":"See Also","text":"<ul> <li>AugmentedDiff - For single diff retrieval</li> <li>OSMChange - For standard changesets</li> </ul>"},{"location":"api/osm/","title":"OSM Data Structures","text":"<p>This module provides classes for working with OpenStreetMap (OSM) data elements.</p>"},{"location":"api/osm/#base-class","title":"Base Class","text":""},{"location":"api/osm/#osmdiff.osm.OSMObject","title":"<code>osmdiff.osm.OSMObject(tags={}, attribs={}, bounds=None)</code>","text":"<p>Base class for all OpenStreetMap elements (nodes, ways, relations).</p> <p>Parameters:</p> Name Type Description Default <code>tags</code> <code>Dict[str, str]</code> <p>Key-value tag dictionary</p> <code>{}</code> <code>attribs</code> <code>Dict[str, str]</code> <p>XML attributes dictionary</p> <code>{}</code> <code>bounds</code> <code>List[float]</code> <p>Optional bounding box coordinates [minlon, minlat, maxlon, maxlat]</p> <code>None</code> Note <p>This is an abstract base class - use Node, Way or Relation for concrete elements.</p> <p>Initialize an empty OSM object.</p> Source code in <code>src/osmdiff/osm/osm.py</code> <pre><code>def __init__(\n    self,\n    tags: Dict[str, str] = {},\n    attribs: Dict[str, str] = {},\n    bounds: List[float] = None,\n) -&gt; None:\n    \"\"\"Initialize an empty OSM object.\"\"\"\n    self.tags = tags or {}\n    self.attribs = attribs or {}\n    self.bounds = bounds or None\n</code></pre>"},{"location":"api/osm/#osmdiff.osm.OSMObject.__repr__","title":"<code>__repr__()</code>","text":"<p>String representation of the OSM object.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Object type and ID, with additional info for ways/relations</p> Source code in <code>src/osmdiff/osm/osm.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"\n    String representation of the OSM object.\n\n    Returns:\n        str: Object type and ID, with additional info for ways/relations\n    \"\"\"\n    out = \"{type} {id}\".format(type=type(self).__name__, id=self.attribs.get(\"id\"))\n    if type(self) == Way:\n        out += \" ({ways} nodes)\".format(ways=len(self.nodes))\n    if type(self) == Relation:\n        out += \" ({mem} members)\".format(mem=len(self.members))\n    return out\n</code></pre>"},{"location":"api/osm/#osmdiff.osm.OSMObject.from_file","title":"<code>from_file(filename)</code>  <code>classmethod</code>","text":"<p>Create object from XML file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>Path to XML file</p> required <p>Returns:</p> Name Type Description <code>OSMObject</code> <code>OSMObject</code> <p>Parsed object</p> Source code in <code>src/osmdiff/osm/osm.py</code> <pre><code>@classmethod\ndef from_file(cls, filename: str) -&gt; \"OSMObject\":\n    \"\"\"\n    Create object from XML file.\n\n    Args:\n        filename: Path to XML file\n\n    Returns:\n        OSMObject: Parsed object\n    \"\"\"\n    with open(filename, \"r\") as f:\n        tree = ElementTree.parse(f)\n        return cls.from_xml(tree.getroot())\n</code></pre>"},{"location":"api/osm/#osmdiff.osm.OSMObject.from_xml","title":"<code>from_xml(elem)</code>  <code>classmethod</code>","text":"<p>Create OSM object from XML element.</p> <p>Parameters:</p> Name Type Description Default <code>elem</code> <code>Element</code> <p>XML element representing an OSM object</p> required <p>Returns:</p> Name Type Description <code>OSMObject</code> <code>OSMObject</code> <p>Appropriate subclass instance</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If XML element is invalid</p> <code>TypeError</code> <p>If element type is unknown</p> Source code in <code>src/osmdiff/osm/osm.py</code> <pre><code>@classmethod\ndef from_xml(cls, elem: Element) -&gt; \"OSMObject\":\n    \"\"\"\n    Create OSM object from XML element.\n\n    Args:\n        elem: XML element representing an OSM object\n\n    Returns:\n        OSMObject: Appropriate subclass instance\n\n    Raises:\n        ValueError: If XML element is invalid\n        TypeError: If element type is unknown\n    \"\"\"\n    if elem is None:\n        raise ValueError(\"XML element cannot be None\")\n\n    osmtype = \"\"\n    if elem.tag == \"member\":\n        osmtype = elem.attrib.get(\"type\")\n        if not osmtype:\n            raise ValueError(\"Member element missing type attribute\")\n    else:\n        osmtype = elem.tag\n\n    if osmtype not in (\"node\", \"nd\", \"way\", \"relation\"):\n        raise TypeError(f\"Unknown OSM element type: {osmtype}\")\n\n    if osmtype in (\"node\", \"nd\"):\n        o = Node()\n    elif osmtype == \"way\":\n        o = Way()\n        o._parse_nodes(elem)\n    elif osmtype == \"relation\":\n        o = Relation()\n        o._parse_members(elem)\n    else:\n        pass\n    o.attribs = elem.attrib\n    o.osmtype = str(o.__class__.__name__).lower()[0]\n    o._parse_tags(elem)\n    o._parse_bounds(elem)\n    return o\n</code></pre>"},{"location":"api/osm/#osmdiff.osm.OSMObject.to_dict","title":"<code>to_dict()</code>","text":"<p>Convert object to dictionary.</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dict[str, Any]: Dictionary representation</p> Source code in <code>src/osmdiff/osm/osm.py</code> <pre><code>def to_dict(self) -&gt; Dict[str, Any]:\n    \"\"\"\n    Convert object to dictionary.\n\n    Returns:\n        Dict[str, Any]: Dictionary representation\n    \"\"\"\n    return {\n        \"type\": self.__class__.__name__,\n        \"id\": self.attribs.get(\"id\"),\n        \"tags\": self.tags,\n        \"bounds\": self.bounds,\n    }\n</code></pre>"},{"location":"api/osm/#osmdiff.osm.OSMObject.to_json","title":"<code>to_json()</code>","text":"<p>Convert object to JSON string.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>JSON representation</p> Source code in <code>src/osmdiff/osm/osm.py</code> <pre><code>def to_json(self) -&gt; str:\n    \"\"\"\n    Convert object to JSON string.\n\n    Returns:\n        str: JSON representation\n    \"\"\"\n    return json.dumps(self.to_dict())\n</code></pre>"},{"location":"api/osm/#osm-elements","title":"OSM Elements","text":""},{"location":"api/osm/#node","title":"Node","text":""},{"location":"api/osm/#osmdiff.osm.Node","title":"<code>osmdiff.osm.Node(tags={}, attribs={}, bounds=None)</code>","text":"<p>               Bases: <code>OSMObject</code></p> <p>OpenStreetMap node (geographic point feature).</p> <p>Implements geo_interface for GeoJSON compatibility as a Point feature. Coordinates must be valid (-180&lt;=lon&lt;=180, -90&lt;=lat&lt;=90).</p> Source code in <code>src/osmdiff/osm/osm.py</code> <pre><code>def __init__(\n    self,\n    tags: Dict[str, str] = {},\n    attribs: Dict[str, str] = {},\n    bounds: List[float] = None,\n) -&gt; None:\n    super().__init__(tags, attribs, bounds)\n</code></pre>"},{"location":"api/osm/#osmdiff.osm.Node.lat","title":"<code>lat</code>  <code>property</code>","text":"<p>Get latitude value.</p>"},{"location":"api/osm/#osmdiff.osm.Node.lon","title":"<code>lon</code>  <code>property</code>","text":"<p>Get longitude value.</p>"},{"location":"api/osm/#osmdiff.osm.Node.__eq__","title":"<code>__eq__(other)</code>","text":"<p>Check if two nodes are equal.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>OSMObject</code> <p>Another OSMObject object</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if nodes have same coordinates</p> Source code in <code>src/osmdiff/osm/osm.py</code> <pre><code>def __eq__(self, other) -&gt; bool:\n    \"\"\"\n    Check if two nodes are equal.\n\n    Args:\n        other (OSMObject): Another OSMObject object\n\n    Returns:\n        bool: True if nodes have same coordinates\n    \"\"\"\n    if not isinstance(other, Node):\n        return False\n    return self.lon == other.lon and self.lat == other.lat\n</code></pre>"},{"location":"api/osm/#way","title":"Way","text":""},{"location":"api/osm/#osmdiff.osm.Way","title":"<code>osmdiff.osm.Way(tags=None, attribs=None, bounds=None, nodes=None)</code>","text":"<p>               Bases: <code>OSMObject</code></p> <p>Represents an OSM way (linear feature).</p> <p>Implements geo_interface for GeoJSON compatibility as either: - LineString for open ways - Polygon for closed ways</p> <p>Initialize a Way object.</p> Source code in <code>src/osmdiff/osm/osm.py</code> <pre><code>def __init__(\n    self,\n    tags: Dict[str, str] = None,\n    attribs: Dict[str, str] = None,\n    bounds: List[float] = None,\n    nodes: List[Node] = None,\n) -&gt; None:\n    \"\"\"Initialize a Way object.\"\"\"\n    self.tags = tags or {}\n    self.attribs = attribs or {}\n    self.nodes = nodes or []\n    super().__init__(tags, attribs, bounds)\n</code></pre>"},{"location":"api/osm/#osmdiff.osm.Way.is_closed","title":"<code>is_closed()</code>","text":"<p>Check if the way forms a closed loop.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if first and last nodes are identical</p> Source code in <code>src/osmdiff/osm/osm.py</code> <pre><code>def is_closed(self) -&gt; bool:\n    \"\"\"\n    Check if the way forms a closed loop.\n\n    Returns:\n        bool: True if first and last nodes are identical\n    \"\"\"\n    return bool(self.nodes and self.nodes[0] == self.nodes[-1])\n</code></pre>"},{"location":"api/osm/#osmdiff.osm.Way.length","title":"<code>length()</code>","text":"<p>Calculate approximate length in meters.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Length of way in meters (not implemented)</p> Source code in <code>src/osmdiff/osm/osm.py</code> <pre><code>def length(self) -&gt; float:\n    \"\"\"\n    Calculate approximate length in meters.\n\n    Returns:\n        float: Length of way in meters (not implemented)\n    \"\"\"\n    # Implementation using haversine formula\n    pass\n</code></pre>"},{"location":"api/osm/#relation","title":"Relation","text":""},{"location":"api/osm/#osmdiff.osm.Relation","title":"<code>osmdiff.osm.Relation(tags=None, attribs=None, bounds=None)</code>","text":"<p>               Bases: <code>OSMObject</code></p> <p>Represents an OSM relation (collection of features).</p>"},{"location":"api/osm/#osmdiff.osm.Relation--attributes","title":"Attributes","text":"<pre><code>members (list): List of member objects\n__geo_interface__ (dict): GeoJSON-compatible interface, see https://gist.github.com/sgillies/2217756 for more details.\n</code></pre>"},{"location":"api/osm/#osmdiff.osm.Relation--example","title":"Example","text":"<pre><code>relation = Relation()\nrelation.members = [Way(), Node()]  # Add members\nprint(relation.__geo_interface__[\"type\"])  # \"FeatureCollection\"\n</code></pre> <p>Initialize a Relation object.</p> Source code in <code>src/osmdiff/osm/osm.py</code> <pre><code>def __init__(\n    self,\n    tags: Dict[str, str] = None,\n    attribs: Dict[str, str] = None,\n    bounds: List[float] = None,\n) -&gt; None:\n    \"\"\"Initialize a Relation object.\"\"\"\n    tags = tags or {}\n    attribs = attribs or {}\n    super().__init__(tags, attribs, bounds)\n    self.members = []\n</code></pre>"},{"location":"api/osmchange/","title":"OSMChange","text":"<p>Core class for retrieving and parsing OpenStreetMap changesets in OSMChange format.</p> <p>For working with the Augmented Diff format, we have AugmentedDiff and ContinuousAugmentedDiff.</p>"},{"location":"api/osmchange/#features","title":"Features","text":"<ul> <li>Retrieves changesets from OSM replication servers</li> <li>Parses OSMChange XML format</li> <li>Handles create/modify/delete actions</li> <li>Supports both remote and local file sources</li> <li>Context manager support</li> <li>Sequence number management</li> </ul>"},{"location":"api/osmchange/#basic-usage","title":"Basic Usage","text":"<pre><code>from osmdiff import OSMChange\n\n# Create with sequence number\nosm_change = OSMChange(sequence_number=12345)\n\n# Retrieve and process changes\nstatus = osm_change.retrieve()\nif status == 200:\n    creations = osm_change.actions[\"create\"]\n    modifications = osm_change.actions[\"modify\"]\n    deletions = osm_change.actions[\"delete\"]\n    print(f\"Created: {len(creations)} features\")\n    print(f\"Modified: {len(modifications)} features\") \n    print(f\"Deleted: {len(deletions)} features\")\n</code></pre>"},{"location":"api/osmchange/#api-reference","title":"API Reference","text":"<p>               Bases: <code>object</code></p> <p>Handles OpenStreetMap changesets in OSMChange format.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>Optional[str]</code> <p>Base URL of OSM replication server</p> <code>None</code> <code>frequency</code> <code>str</code> <p>Replication frequency (\u2018minute\u2019, \u2018hour\u2019, or \u2018day\u2019)</p> <code>'minute'</code> <code>file</code> <code>Optional[str]</code> <p>Path to local OSMChange XML file</p> <code>None</code> <code>sequence_number</code> <code>Optional[int]</code> <p>Sequence number of the diff</p> <code>None</code> <code>timeout</code> <code>Optional[int]</code> <p>Request timeout in seconds</p> <code>None</code> Note <p>Follows the OSM replication protocol.</p> Source code in <code>src/osmdiff/osmchange.py</code> <pre><code>def __init__(\n    self,\n    url: Optional[str] = None,\n    frequency: str = \"minute\",\n    file: Optional[str] = None,\n    sequence_number: Optional[int] = None,\n    timeout: Optional[int] = None,\n):\n    # Initialize with defaults from config\n    self.base_url = url or API_CONFIG[\"osm\"][\"base_url\"]\n    self.timeout = timeout or API_CONFIG[\"osm\"][\"timeout\"]\n\n    self.create = []\n    self.modify = []\n    self.delete = []\n\n    if file:\n        with open(file, \"r\") as fh:\n            xml = ElementTree.iterparse(fh, events=(\"start\", \"end\"))\n            self._parse_xml(xml)\n    else:\n        self._frequency = frequency\n        self._sequence_number = sequence_number\n</code></pre>"},{"location":"api/osmchange/#osmdiff.osmchange.OSMChange.sequence_number","title":"<code>sequence_number</code>  <code>property</code> <code>writable</code>","text":""},{"location":"api/osmchange/#osmdiff.osmchange.OSMChange.frequency","title":"<code>frequency</code>  <code>property</code> <code>writable</code>","text":""},{"location":"api/osmchange/#osmdiff.osmchange.OSMChange.actions","title":"<code>actions</code>  <code>property</code>","text":"<p>Get all actions combined in a single list.</p>"},{"location":"api/osmchange/#osmdiff.osmchange.OSMChange.get_state","title":"<code>get_state()</code>","text":"<p>Retrieve the current state from the OSM API.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if state was successfully retrieved, False otherwise</p> <p>Raises:</p> Type Description <code>RequestException</code> <p>If the API request fails</p> Source code in <code>src/osmdiff/osmchange.py</code> <pre><code>def get_state(self) -&gt; bool:\n    \"\"\"\n    Retrieve the current state from the OSM API.\n\n    Returns:\n        bool: True if state was successfully retrieved, False otherwise\n\n    Raises:\n        requests.RequestException: If the API request fails\n    \"\"\"\n    state_url = urljoin(self.base_url, \"api/0.6/changesets/state\")\n    response = requests.get(\n        state_url, timeout=self.timeout, headers=DEFAULT_HEADERS\n    )\n    if response.status_code != 200:\n        return False\n\n    # Parse XML response\n    root = ElementTree.fromstring(response.content)\n    state = root.find(\"state\")\n    if state is not None:\n        seq = state.find(\"sequenceNumber\")\n        if seq is not None and seq.text:\n            self._sequence_number = int(seq.text)\n            return True\n    return False\n</code></pre>"},{"location":"api/osmchange/#osmdiff.osmchange.OSMChange.retrieve","title":"<code>retrieve(clear_cache=False, timeout=None)</code>","text":"<p>Retrieve the OSM diff corresponding to the OSMChange sequence_number.</p> <p>Parameters:</p> Name Type Description Default <code>clear_cache</code> <code>bool</code> <p>clear the cache</p> <code>False</code> <code>timeout</code> <code>int</code> <p>request timeout</p> <code>None</code> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>HTTP status code</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If an invalid sequence number is provided</p> Source code in <code>src/osmdiff/osmchange.py</code> <pre><code>def retrieve(self, clear_cache: bool = False, timeout: Optional[int] = None) -&gt; int:\n    \"\"\"\n    Retrieve the OSM diff corresponding to the OSMChange sequence_number.\n\n    Parameters:\n        clear_cache (bool): clear the cache\n        timeout (int): request timeout\n\n    Returns:\n        int: HTTP status code\n\n    Raises:\n        Exception: If an invalid sequence number is provided\n    \"\"\"\n    if not self._sequence_number:\n        raise Exception(\"invalid sequence number\")\n    if clear_cache:\n        self.create, self.modify, self.delete = ([], [], [])\n    try:\n        r = requests.get(\n            self._build_sequence_url(),\n            stream=True,\n            timeout=timeout or self.timeout,\n            headers=DEFAULT_HEADERS,\n        )\n        if r.status_code != 200:\n            return r.status_code\n        # Handle both gzipped and plain XML responses\n        content = r.content\n        if content.startswith(b\"\\x1f\\x8b\"):  # Gzip magic number\n            gzfile = GzipFile(fileobj=r.raw)\n            xml = ElementTree.iterparse(gzfile, events=(\"start\", \"end\"))\n        else:\n            xml = ElementTree.iterparse(r.raw, events=(\"start\", \"end\"))\n        self._parse_xml(xml)\n        return r.status_code\n    except ConnectionError:\n        # FIXME catch this?\n        return 0\n</code></pre>"},{"location":"api/osmchange/#osmdiff.osmchange.OSMChange.__repr__","title":"<code>__repr__()</code>","text":"Source code in <code>src/osmdiff/osmchange.py</code> <pre><code>    def __repr__(self):\n        return \"OSMChange ({create} created, {modify} modified, \\\n{delete} deleted)\".format(\n            create=len(self.create), modify=len(self.modify), delete=len(self.delete)\n        )\n</code></pre>"},{"location":"api/osmchange/#osmdiff.osmchange.OSMChange.__enter__","title":"<code>__enter__()</code>","text":"Source code in <code>src/osmdiff/osmchange.py</code> <pre><code>def __enter__(self):\n    return self\n</code></pre>"},{"location":"api/osmchange/#osmdiff.osmchange.OSMChange.__exit__","title":"<code>__exit__(exc_type, exc_val, exc_tb)</code>","text":"<p>Clear all changes when exiting context.</p> Source code in <code>src/osmdiff/osmchange.py</code> <pre><code>def __exit__(self, exc_type, exc_val, exc_tb):\n    \"\"\"Clear all changes when exiting context.\"\"\"\n    self.create.clear()\n    self.modify.clear()\n    self.delete.clear()\n</code></pre>"},{"location":"api/osmchange/#see-also","title":"See Also","text":"<ul> <li>AugmentedDiff - For augmented diffs with additional metadata</li> </ul>"},{"location":"api/utils/","title":"Utilities","text":""},{"location":"api/utils/#settings","title":"Settings","text":""},{"location":"api/utils/#version-information","title":"Version Information","text":""},{"location":"examples/","title":"Examples","text":"<p>Here are some examples of how to use the OSMDiff library.</p>"},{"location":"examples/#basic-augmented-diff-usage","title":"Basic Augmented Diff Usage","text":"<pre><code>from osmdiff import AugmentedDiff\n\n# Create an AugmentedDiff instance for a specific area\nad = AugmentedDiff(\n    minlon=-0.489,  # London bounding box\n    minlat=51.28,\n    maxlon=0.236,\n    maxlat=51.686\n)\n\n# Get current state and retrieve changes\nad.get_state()\nstatus = ad.retrieve()\n\nif status == 200:\n    print(f\"Changes retrieved:\")\n    print(f\"  Created: {len(ad.create)}\")\n    print(f\"  Modified: {len(ad.modify)}\")\n    print(f\"  Deleted: {len(ad.delete)}\")\n</code></pre>"},{"location":"examples/#continuous-monitoring","title":"Continuous Monitoring","text":"<p>For continuous monitoring of changes, use the ContinuousAugmentedDiff class:</p> <pre><code>from osmdiff import ContinuousAugmentedDiff\n\n# Create continuous fetcher for London area\nfetcher = ContinuousAugmentedDiff(\n    minlon=-0.489,\n    minlat=51.28,\n    maxlon=0.236,\n    maxlat=51.686,\n    min_interval=30,  # Check at least every 30 seconds\n    max_interval=120  # Back off up to 120 seconds if no changes\n)\n\n# Process changes as they come in\nfor diff in fetcher:\n    print(f\"\\nNew changes in diff {diff.sequence_number}:\")\n    print(f\"  Created: {len(diff.create)} objects\")\n    print(f\"  Modified: {len(diff.modify)} objects\")\n    print(f\"  Deleted: {len(diff.delete)} objects\")\n\n    # Process specific changes\n    for obj in diff.create:\n        if \"amenity\" in obj.tags:\n            print(f\"New amenity: {obj.tags['amenity']}\")\n</code></pre>"}]}